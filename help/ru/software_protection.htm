<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link rel="Stylesheet" type="text/css" href="default.css" />
  <meta http-equiv="Content-Type" content=
  "text/html; charset=utf-8" />

  <title>Изучение, взлом и защита программного обеспечения</title>
</head>

<body>
  <h1>Изучение, взлом и защита программного обеспечения</h1>

  <p>Изучение программного продукта может осуществляться методом
  статического и/или динамического анализа. При статическом анализе
  разработка алгоритма взлома защиты производится на основе анализа
  результатов дизассемблирования или декомпиляции взламываемой
  программы. Динамический анализ чаще всего применяют при взломе
  программных продуктов, исполняемый код которых зашифрован или
  динамически изменяется, так как статический анализ подобных
  программ сопряжен с определенными трудностями.</p>

  <p>Для динамического анализа взламываемую программу запускают в
  среде отладчика, при этом становится возможным контроль всех
  изменений, возникающих в процессе функционирования приложения. В
  процессе динамического анализа, используя режим отладки,
  производят пошаговое прохождение "защитных" алгоритмов программы,
  в частности алгоритмов проверки и генерации корректного
  регистрационного кода. Еще одним средством, применяемым при
  динамическом анализе, являются мониторы активности, отслеживающие
  обращение взламываемой программы к файлам, системным сервисам,
  портам и внешним устройствам.</p>

  <p>Основным инструментом, применяемым для защиты приложений от
  взлома, являются <a href=
  "dictionary.htm#Protector">программы-протекторы</a>. Защита,
  реализуемая большинством протекторов, заключается в том, что они
  <a href="dictionary.htm#Pack">упаковывают</a> и/или <a href=
  "dictionary.htm#Crypt">шифруют</a> исходный исполняемый файл,
  уделяя основное внимание защите процедуры распаковки/расшифровки
  файла.</p>

  <p>Подобный алгоритм работы протекторов очень часто оказывается
  причиной недостаточной степени защиты обеспечиваемой большинством
  из них. В случае если приложение защищено с использованием
  упаковки, по окончании работы распаковщика в распоряжении
  злоумышленника может оказаться исходный файл, который может быть
  получен при дампе определенной области памяти. Более того, для
  борьбы с самыми распространенными протекторами взломщики
  разработали множество программных инструментов, позволяющих
  взламывать защиту в автоматическом режиме. Аналогичный подход
  применяется при борьбе с шифрованием: после получения
  лицензионного ключа, который в том числе может быть легально
  приобретен, взломщик сможет расшифровать защищенные участки
  кода.</p>

  <p>Ряд программ-протекторов применяют различные антиотладочные
  приемы. Однако применение антиотладки значительно снижает
  быстродействие программы. Также следует помнить, что
  антиотладочные приемы действенны лишь против динамического
  анализа и совершенно не эффективны против статического. Более
  того, все антиотладочные приемы, применяемые в современных
  протекторах, уже давно изучены, а взломщиками написано множество
  утилит, которые их полностью нейтрализуют. На эффективность
  использования мониторов активности встроенные в приложение
  средства защиты от отладки не влияют.</p>

  <p>Более эффективными методами защиты приложения являются
  <a href="dictionary.htm#Obfuscation">обфускация</a> и <a href=
  "dictionary.htm#Virtualization">виртуализация</a>, усложняющие
  анализ кода защищаемого приложения. В общем случае эффективность
  данных методов достигается за счет использования особенностей
  человеческого фактора - чем сложнее исходный код, чем больше
  ресурсов использует приложение, тем человеку его анализирующему
  тяжелее понять логику работы программы, а следовательно, и
  взломать примененные средства защиты.</p>

  <p>При обфускации производится запутывание кода приложения за
  счет введения дополнительных инструкций. При виртуализации
  исходный код преобразуется в <a href=
  "dictionary.htm#ByteCode">байт-код</a>, выполнение которого
  осуществляется на специальном интерпретаторе, имитирующем
  виртуальную машину со специфической системой команд.
  Следовательно, применение виртуализации приводит к высокой и
  неснижаемой степени запутанности результирующего кода, а при
  определенном подходе к реализации этого метода защищенный код не
  содержит методов восстановления оригинального кода в явном виде.
  Таким образом, важнейшим преимуществом виртуализации является то,
  что в момент выполнения виртуализированного участка кода не
  происходит его обратного преобразования в машинные коды
  процессора, а это исключает возможность получения взломщиком
  оригинального кода приложения.</p>

  <p>Задача обратного инжиниринга виртуализированных фрагментов
  сводится к изучению архитектуры <a href=
  "dictionary.htm#VirtualMachine">виртуальной машины</a>, созданию
  дизассемблера, соответствующего архитектуре имитируемого
  виртуальной машиной процессора, и анализу дизассемблированного
  кода. При определенном подходе к реализации виртуальной машины
  задача создания дизассемблера виртуализированного кода становится
  достаточно трудоемкой. Единственным недостатком виртуализации
  является сравнительно низкая скорость работы, поэтому этот метод
  следует применять только для защиты участков кода, некритичных к
  скорости исполнения.</p>

  <p>В подавляющем большинстве современных протекторов методы
  обфускации и виртуализации играют второстепенную роль, а уровень
  их реализации недостаточен, что позволяет взломщикам выполнять
  снятие подобной защиты в автоматизированном или ручном режиме.
  Еще одним слабым местом многих современных протекторов является
  использование недокументированных функций Windows, что создает
  ограничения для использования приложения в новых версиях
  операционной системы или при включенном режиме DEP.</p><br />
  <br />
  <br />
  <br />
  <br />
  <hr noshade="noshade" size="1" />

  <div align="center">
    © 2006-2015 Copyright VMProtect Software
  </div>
</body>
</html>
